# Семинар 2.

---

## Задание 1_1.

Создать package – animals. Работу продолжаем в нём.

Создать абстрактный класс Animal с полями год рождения, вес, кол-во конечностей.

Реализовать наследников класса Animal классы Lion и Snake, добавив к ним по одному доп. полю объем гривы и длина тела соответственно.

*4.  Реализовать метод  кормления void feed(int foodWeight), после которого вес животного увеличивается.

---

## Задание 1_2.

Создать в классе Lion и Snake статичные финальные поля MAX_WEIGHT и TYPE, на той же строке объявления присвоить им значения.

Добавить логику в метод feed, чтобы животное не могло превысить свой максимальный вес.

*3. Реализовать логику так, чтобы метод feed находился в классе Animal и использовал внутри себя абстрактный метод.

---

## Задание 1_3.

Создать package – cage. Работу продолжаем в нём.

Создать интерфейс AnimalCage, который содержит абстрактные методы для:
- Добавления в клетку животного.
- Передачи корма в клетку.
- Очистку клетки.

Создать для сущности Lion отдельный класс LionCage, реализующий интерфейс AnimalCage.

В клетке должна хранится информация о находящихся в ней львах и объем загрязнения клетки.

---

## Задание 2.

Создать package – factory. Работу продолжаем в нём.

Создать класс LionsFactory.

Реализовать в нём статический метод для создания коллекции львов с определённым кол-вом: ArrayList<Lion> createLions (int lionCount);

В методе main создать коллекцию львов и положить её содержимое в клетку.

Посмотрите состояние львов, покормите львов в клетке, проверьте изменился ли у них вес.

---

## ДЗ.

Создать класс Wolf, наследника класса Animal.

Создать класс WolfCage, имплементирующий интерфейс AnimalCage.

Добавить абстрактный метод в интерфейс AnimalCage, достающий первое попавшееся животное из клетки.

Все вышеуказанное создать согласно принципам ООП пройдённым на семинаре.

---

# Семинар 3.

---

## Задание 1.

Модифицировать класс Lion, заставив его реализовать интерфейс Comparable<Lion>.

Реализовать контракт compareTo() со сравнением по возрасту льва.

Добавить в класс LionCage метод сортировки львов по возрасту void sortLions().

---

## Задание 2.

Создать класс LionComporator, руализующий интерфейс Comparator<Lion>.

Реализовать контракт compare() со сравнением по объёму гривы.

Модифицировать LionCage, добавив в него метод сортировки львов по гриве.

---

## Задание 3.

Создать класс LionIterator, заставив его реализовать интерфейс Iterator<Lion>.

Объявить в классе поле с типом ArrayList<Lion>.

Реализовать абстрактные методы.

*Реализовать метод remove().

---

## Задание 4.

Модифицировать клас LionCage, заставив его реализовать интерфейс Iterable<Lion>.

Реализовать метод iterator(), возвращающий эеземпляр класса LionIterator.

Модифицировать класс LionCage, добавив в него метод удаления льва старше определённого возраста - void deleteLionOlderThan(int limitAge);

---

## ДЗ.

Создать класс WolfComparator, реализующий сравнение волков по их весу и возрасту.

В классе WolfCage добавить метод сортировки волков, используя созданный WolfComparator.

Имплементировать в классе WolfCage интерфейс Iterable<Wolf> и реализовать логику итерации по волкам в клетке с помощью класса WolfIterator.

---

# Семинар 4.

---

## Задание 1.

Обобщить интерфейс AnimalCage, добавив к имени интерфейса "<T>".

Сделать так, чтобы абстрактные методы использовали дженерик <T>.

Проанализировать изменения в классах, реализующих AnimalCage.

---

## Задание 2.

Обобщить интерфейс AnimalCage так, чтобы он работал только с наследниками класса Animal, добавив к имении интерфейса "<T extends>".

Добавить в интерфейс дефолтный метод, который сортировал бы коллекцию из T по году рождения: default List<T> sortByAge(List<T> animalList).

---

## Задание 3.

Создать пэкедж zoo, работу продолжаем в нём.

Создать класс Zoo и объявить у него 3 переменные:
- Клетка с волками.
- Клетка со львами.
- Террариум со змеями.

Использовать как можно более абстрактный тип переменных.

---

## Задание 4.

Создать пэкедж animalUtils, работу продолжаем в нём.

Создать класс AnimalUtils и реализовать в нём статический метод для сортировки списка животных по возрасту.

<T extends Animal> List<T> sortAnimals (List<T> animalList).

---

## ДЗ.

Выполнить все задания из семинара 4.

Имплементировать обобщенный интерфейс AnimalCage в классах SnakeCage и WolfCage.

Переписать классы из ДЗ1 с использованием дженериков.

---

# Семинар 5.

---

## Задание 1.

Создать пекедж terminal. Дальнейшие работы ведём в нём.

Создать интерфейс CommandParser с методом String[] parseCommand (String inputCommand).

Создать класс TerminalReader, который содержит переменную CommandParser и метод, который в бесконечном цикле слушает команды с помощью Scanner(System.in).

---

## Задание 2.

Сделать класс TerminalReader синглтоном.

---

## Задание 3.

Создать интерфейс CommandExecutable с абстрактным методом execute().

Реализовать 2 класса, имплементировав созданный интерфейс, CreateLionExecutable и DeletLionExecutable. В унаследованных методах они должны обращаться к методам класса LionCage объекта Zoo.

Подумать какие переменные могли бы содержать созданные классы.

---

## ДЗ.

Повторить функционал с семинара №5.

Создать класc CommandExecutableFactory. Реализовать в нём метод CommandExecutable create (String[] input), где в зависимости от переданных параметров создается тот или иной класс.

Дописать тело метода endless() класса TerminalReader, так чтобы введенная команда парсилась, на результате парсинга создавался объект CommandExecutable и вызывался метод execute().

---

# Семинар 6.

---

## Задание 1.

Создать класс Command, который бы инкапсулировал в себе содержимое введённой команды.

Изменить сигнатуру у интерфейса ParseCommand, чтобы он вместо массива строк начал возвращать объект класса Command.

Реализовать в нём булевские методы для проверки введённых команд.

Отредактировать класс CommandExecutableFactory, убрав из него хардкод и начав принимать на вход объект Command.

---

## Задание 2.

Создать класс LoggingCommandExecutableFactory, наследующий класс CommandExecutableFactory.

Переопределить единственный метод так, чтобы он вызывал внутри себя метод предка, но в начале и конце распечатывал информацию о входных и выходных параметрах.

---

## Задание 3.

Создать отдельно пустой проект.

Реализовать 2 класса Square(квадрат) и Rectangle(прямоугольник)

Реализовать у этих классов константы со сторонами, аксессоры и метод для вычисления площади.

---

## Задание 4.

Переименовать класс CommandExecutableFactory в CommandExecutableFactoryImpl.

Создать интерфейс CommandExecutableFactory и имплементировать от него класс CommandExecutableFactoryImpl.

В классе TerminalReader реализовать DIP, то есть возможность менять реализации CommandExecutable Factory.

---

## ДЗ.

Повторить задания с семинара 6.

Проверить и отредактировать весь проект на предмет соответствия SOLID.

Вместе с ссылкой указать, что вы поменяли и исходя из какого принципа.

Продумать логику отображения результата выполнения команды.

---

# Семинар 7.

---

## Задание 1.

Создать реализацию CommandParser. Чтобы разбить строку используйте метод split().

Запустить приложение, вызвав метод класса TerminalReader, не забыв создать экземпляры зависимостей.

---

## ДЗ.

Повторить задания 1 с семинара 7.

Реализовать отладочную печать, чтобы было видно содержимое клеток в зоопарке.

Критерии оценки :
* приложение запускается
* можно с терминала создавать и удалять животных

---